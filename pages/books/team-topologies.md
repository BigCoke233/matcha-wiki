# Team Topologies

## 1 - The Problem with Org Charts

- La plupart des organisations utilisent l’**organigramme** de l’entreprise pour représenter les intéractions et la division du travail.
  - Mais dans la réalité une telle représentation ne peut pas tenir, et les gens contactent ceux qu’ils ont besoin de contacter pour mener à bien leur tâches.
  - On pourrait comparer ça à un document d’architecture, qui devient obsolète dès qu’il est écrit.
- La manière de voir les organisations évolue :
  - Le livre **_Improving Performance_** de Geary Rummler et Alan Brache pose une première étape d’amélioration continue du business.
  - Le livre **_Project to Product_** de Mik Kersten va un cran plus loin en mettant l’accent sur le produit, et la centralité des équipes.
  - **_Team Topologies_** se veut être une étape de plus dans cette direction.
- Niels Pflaeging, dans **_Organize for Complexity_**, :
  - Identifie 3 structures dans l’organisation :
    - **Formal structure** : l’organigramme.
    - **Informal structure** : le domaine d’influence entre individus.
    - **Value creation structure** : la manière concrète dont le travail se fait, basé sur les relations au sein de l’équipe et entre équipes.
  - Lui et d’autres auteurs comme Frédéric Laloux, ou Brian Robertson (Holacracy), pensent que le point de plus important dans les organisations est le lien entre _informal structure_ et _value creation structure_.
  - Ce livre propose d’aller dans le même sens : **renforcer la cohésion au sein de l’équipe** en la rendant autonome, et **améliorer la confiance inter-équipe** en clarifiant les interactions attendues.
- Ce livre s’appuie sur la **loi de Conway** :
  - Mel Conway avait fait un article de 1968, finissant par dire que le design des systèmes produits par les organisations étaient des **copies de leur structure de communication**.
  - Conway parle bien de la communication réelle, c’est-à-dire de la _value creation structure_ (au sens de Pfaeging).
  - Quand l’architecture voulue est en contradiction avec la structure de l’organisation, l’un des deux est amené à changer.
  - A l’inverse, James Lewis a eu l’idée de mettre en œuvre une “_reverse Conway maneuver_”, où il s’agit de mettre en place une organisation spécifique qui permet l’émergence de l’architecture voulue.
- La **charge cognitive** d’une équipe a tendance à grossir avec le temps.
  - Si on veut que l’équipe puisse être efficace et motivée, il faut la limiter explicitement.
- Traiter le développement logiciel comme une sorte d’usine mène à des équipes inefficaces et démotivées.
  - Les mouvements Agile, Lean et DevOps offrent une solution au travers des équipes autonomes, travaillant itérativement avec les feedbacks de l’utilisateur.

## 2 - Conway’s Law and Why it Matters

- La loi de Conway a été depuis confirmée par de nombreuses études, y compris dans des industries différentes (automobile, aviation etc.).
- La version moderne de cette loi se résume à une citation de Ruth Malan : **“If the architecture of the system and the architecture of the organization are at odds, the architecture of the organization wins”**.
  - Une organisation qui est organisée en silos techniques (équipes QA, DBA, sécurité etc.) ne pourra pas produire de système architecturé pour l’optimisation du flow.
  - Autre exemple : une organisation qui s’organise principalement autour de la vente dans des régions géographiques a peu de chances de mettre en place une architecture logicielle globale qui fournit des services à toutes les régions.
- Le **Reverse Conway Maneuver** est une pratique qui fonctionne.
  - Les recherches menées par les auteurs d’**_Accelerate_** montrent que c’est efficace.
  - Le but c’est de transformer l’organisation pour créer un contexte où le travail peut être fait de bout en bout, sans avoir besoin d’une communication inter-équipe importante.
  - Par exemple, si on a 4 équipes de devs back et front, qui transfèrent le travail à une unique équipe DBA, on va obtenir 4 applications back/front, et une seule DB centralisée.
    - Dans le cas où on voudrait une DB par app, on peut dissoudre l’équipe DBA, et intégrer ses membres aux 4 équipes.
    - La tendance naturelle va être l’émergence de l’architecture qu’on voulait.
- Il faut concevoir l’architecture des systèmes de manière à obtenir des **modules de la taille d’une équipe**.
- La structuration de l’organisation nécessite des compétences techniques.
  - Il faut au minimum impliquer des personnes techniques (qui comprennent les notions d’abstraction, encapsulation etc.) dans le choix du type d’équipes, de leur scope etc.
  - Selon Ruth Malan : “_If we have managers deciding which service will be built, by which teams, we implicitly have managers deciding on the system architecture_”.
  - Selon Allan Kelly, une personne se disant **architecte** doit avoir des compétences techniques, mais aussi de management.
- Il faut **limiter la communication non nécessaire entre équipes**.
  - Il faut définir les patterns de communication entre équipes, en fonction de l’architecture du système qu’on veut mettre en place.
    - Si les équipes communiquent en dehors de ces canaux, alors c’est qu’il y a sans doute quelque chose qui ne va pas : mauvaise API ? Composants mal agencés ou manquants ? etc.
    - On peut monitorer le volume de communication en ligne pour vérifier que les patterns de communication sont les bons.
  - Si deux équipes communiquent juste parce que leur code se trouve dans un dépôt commun ou une application commune, alors on peut les séparer en utilisant les _fracture plane patterns_ (chapitre 6).
- La gestion des **outils** peut aider à respecter les patterns de communication :
  - Il faut des outils partagés entre équipes qui collaborent, et des outils séparés entre équipes indépendantes.
- Certaines entreprises font l’erreur d’avoir de nombreuses équipes chargées de petites parties du système (des complicated subsystem teams). Ça doit rester une exception, et la norme doit être les équipes alignées sur le flow.
- Les réorganisations régulières pour réduire les effectifs ou pour donner des postes à la hiérarchie de management sont incompatibles avec une organisation basée sur la loi de Conway, la notion de cognitive load etc.

## 3 - Team-First Thinking

- Citation d’Allan Kelly dans **_Project Mytopia_** : _“Disbanding high-performing teams is worse than vandalism: it is corporate psychopathy”_.
- La recherche montre que, dans les domaines de résolution de problèmes où il y a une grande quantité d’information à traiter, **les équipes cohésives ont une meilleure performance que les individus**.
  - cf. Driskell and Salas, [Collective Behavior and Team Performance](https://www.researchgate.net/publication/239937465_Collective_Behavior_and_Team_Performance).
  - Une étude de Google sur ses propres équipes a montré que la dynamique d’équipe compte plus pour la performance que les individus qui la composent.
- Pour les auteurs, une **équipe** est un groupe de **5 à 9 personnes** qui travaillent avec un but commun.
  - L’équipe est **la plus petite unité** de l’entreprise. On n’assigne donc pas de tâches aux individus.
  - Le nombre de personnes est basé sur le nombre de Dunbar (suite aux recherches de l’anthropologue Robin Dunbar)
    - Dunbar dit qu’une personne peut faire avoir confiance envers 15 personnes, et avoir une confiance profonde envers 5 personnes.
    - Ca fonctionne par cercles concentriques pour les échelles suivantes : 50, 150 et 500 personnes.
  - Si on dépasse 9 personnes, la confiance ne tient plus et l’équipe n’est plus cohésive.
  - Dans certaines entreprises avec une forte culture de la confiance, on peut monter jusqu’à 15 personnes, mais elles sont plutôt l’exception.
- Les équipes doivent être **stables dans le temps**.
  - Elles mettent plusieurs semaines à plusieurs mois après la formation pour atteindre leur rythme de croisière.
    - Avec une phase de “storming” où chacun s’habitue aux comportements des autres cf. modèle de Truckman.
  - Réorganiser les équipes selon des projets de 6 mois va les mettre en situation de réadaptation permanente.
  - En fonction de la culture de confiance de l’entreprise, une personne peut changer d’équipe tous les 1 à 2 ans sans impact majeur sur la performance des équipes.
- **L’équipe doit avoir l’ownership **sur les composants sur lesquels elle travaille.
  - Si la même équipe intervient sur le même logiciel tout au long, elle peut planifier le court, moyen et long terme.
    - Elle se sent responsable en cas de raccourcis pris dans le code.
  - Il ne doit pas y avoir de parties du logiciel sous la responsabilité de plusieurs équipes.
- Les membres des équipes doivent avoir un **team-first mindset**.
  - Il s’agit de mettre les besoins de l’équipe au-dessus des leurs :
    - Aider/débloquer les autres, mentorer les nouveaux.
    - Se concentrer sur les objectifs d’équipe.
    - Être ouvert à l’exploration de nouvelles options, plutôt que de chercher à imposer son avis.
  - Il existe des personnes “team toxic”, qui n’aiment pas le travail en équipe, et n’arrivent pas à s’y adapter. Elles doivent être écartées des équipes avant d’y causer des dommages.
    - Ce point est largement validé par la recherche.
- La recherche montre que les équipes diverses ont plus de chances de produire des solutions créatives, rapides et ont plus de facilité à entrer en empathie avec les autres équipes.
- Il vaut mieux donner des **bonus d’équipe**, plutôt qu’individuels.
  - On peut faire la même chose pour le budget formation, qu’on confie à l’équipe pour qu’elle le dépense comme bon lui semble.
- Il faut faire attention à surveiller et **limiter la cognitive load** de l’équipe.
  - Il s’agit de la quantité d’effort mental qu’on doit utiliser pour notre mémoire de travail.
    - La notion a été théorisée par le psychologue John Sweller.
  - Il identifie 3 types de cognitive load :
    - **Intrinsic cognitive load** : tout ce qui fait partie des fondamentaux à connaître pour résoudre le problème.
      - Exemple : Fondamentaux de la programmation, spécificités d’un langage en particulier.
      - Il faut la minimiser par des formations, du pair programming etc.
    - **Extraneous cognitive load** : ce qui concerne l’utilisation de l’environnement de la tâche.
      - Exemple : Comment déployer un service (commandes à taper etc.), comment configurer un outil etc.
      - Il faut l’éliminer par l’automatisation des tâches.
    - **Germane cognitive load** : la partie complexe propre au problème.
      - Exemple : La manière dont un service devrait interagir avec cet autre, la logique business d’un service etc.
      - On doit limiter ou éliminer les autres formes pour se concentrer sur celle-là qui est celle qui apporte de la valeur.
  - Il faut donc à la fois limiter le scope d'action de l’équipe (germane cognitive load), et les laisser se former et automatiser les tâches (intrinsic et extraneous cognitive load).
    - Pour diminuer la cognitive load on peut aussi mettre en place un management basé sur les outcomes, diminuer la paperasse et les meetings, et avoir une équipe platform bien découplée.
  - Pour mesurer la cognitive load d’une équipe, la manière la plus rapide et efficace est de **demander aux membres de l’équipe s’ils se sentent surchargés**.
    - La mesure par le nombre de lignes de code ou ce genre de choses ne marche pas très bien.
  - Une fois qu’on a identifié les subdomains, on peut appliquer des **heuristiques** pour l’attribution aux équipes.
    - On peut les classer par complexité relative :
      - Simple : on sait comment faire l'essentiel du travail.
      - Compliqué : il faudra faire de l’analyse et itérer.
      - Complexe : il faudra faire beaucoup d'expérimentation.
    - Les heuristiques sont :
      - 1 - Assigner **chaque subdomain** à une équipe.
        - Si un subdomain est trop gros, on le découpe d’abord.
      - 2 - Assigner **2 ou 3 subdomains** simples à une équipe.
      - 3 - Assigner **un seul subdomain complexe** à une équipe.
        - Une des raisons c’est qu’elle ne pourra pas avoir tendance à traiter d’abord les tâches simples.
      - 4 - Ne pas mettre **deux subdomains complexes** dans une même équipe.
- Il faut que chaque équipe **définisse et documente sa relation aux autres équipes** (sa “Team API”).
  - Ça inclut le code et la documentation de l’API disponible, et comment éventuellement y contribuer, la manière dont l’équipe travaille, communique, ce sur quoi ils travaillent actuellement etc.
    - Le but c’est qu’une autre équipe puisse facilement trouver ce qu’il lui faut par elle-même, et trouver comment collaborer avec eux en cas de besoin.
- Pour permettre une certaine communication entre équipes autonomes sans compromettre l’autonomie, on peut **laisser du temps pour des activités de “guildes”**, où des membres de diverses équipes s’organisent autour de sujets qui les intéressent, pour du partage de connaissances et de l’apprentissage.
- **L’environnement de travail doit être explicitement pensé**, qu’il soit physique ou virtuel.
  - Il faut que le lieu de travail permette :
    - Des moments de travail sans être dérangé.
    - Une collaboration fréquente entre membres de l’équipe.
    - Une collaboration occasionnelle avec les membres des autres équipes.
  - Spotify a organisé, dès 2012, ses équipes en squads ayant un espace commun, et tribes (squads liées entre-elles) situées au même endroit.
    - CDL (une entreprise d’assurance UK) et la banque ING Netherlands ont fait le même genre de chose.
  - Chez Auto Trader, ils ont mis ensemble les équipes techniques et non techniques (sales, product, marketing etc.) qui travaillaient pour la même business area et les mêmes clients.
    - Le but est de favoriser la collaboration et augmenter l’empathie entre membres du même flow stream-aligned.
    - Ils ont aussi permis aux personnes de facilement déplacer leurs affaires pour s’installer là où c’est le plus utile sur le moment, et ont mis en place des espaces communs à ces équipes.
  - Dans le cas du **remote first**, il faut aussi organiser l’environnement :
    - Jason Fried et DHH adressent ce problème dans leur livre **_Remote: Office Not Required_**.
    - L'environnement comprend les outils (chat, wiki, reporting etc.), mais aussi les règles qu’on se fixe (horaires, temps de réponse, manière de communiquer, conf calls etc.).
    - Côté outil de chat, n peut utiliser des canaux préfixés : `#team-vesuvius`, `#support-logging`, `#practices-testing`
- Attention à ne pas oublier les pratiques techniques fondamentales (continuous delivery, TDD etc.), sans elles le team-first n’ira pas bien loin.

## 4 - Static Team Topologies

- Les auteurs ont identifié deux **team anti-patterns** :
  - 1 - Les **équipes ad hoc** qu’on crée sans trop réfléchir, par exemple :
    - Des équipes qui avaient trop grandi et qui sont découpées au hasard.
    - Des équipes qui s’occupent de tout le middleware.
    - Des équipes DBA créés après un crash de la prod à cause des problèmes de DB.
  - 2 - Le fait de **remélanger les équipes** régulièrement, au gré des projets qui commencent et se terminent.
- Le critère que les organisations doivent chercher à optimiser c’est le **flow de changement rapide**.
  - C’est important pour pouvoir s’adapter rapidement aux clients et au marché.
  - Spotify, avec [son papier de 2012](https://blog.crisp.se/wp-content/uploads/2012/11/SpotifyScaling.pdf) (qui a donné lieu au célèbre “Spotify model”) est un exemple connu de tournant vers ce modèle favorisant le flow rapide.
    - Ils avaient des équipes appelées _squads_, pluridisciplinaires, stables et composées de 5 à 9 personnes.
    - Les équipes étaient regroupées en _tribes_ contenant plusieurs squads qui collaboraient entre-elles plus qu’avec les autres squads.
      - Par exemple, les testeurs de chaque squad d'une même tribe formaient un _chapter_, et se rencontraient régulièrement pour se synchroniser.
    - Un dernier concept utilisé était celui de _guilds_, où il s’agissait de regrouper des communautés de pratique informelles autour de thématiques techniques.
  - Pour avoir un flow rapide et répondre aux besoins des clients, les équipes qui conçoivent et développent le logiciel doivent avoir un **feedback régulier depuis la production**.
- Les auteurs de ce livre ont par le passé créé un ensemble de patterns pour structurer les équipes et leurs interactions, appelés **DevOps Topologies**.
  - Il y a deux idées importantes avec ces patterns :
    - 1 - Le fait que telle ou telle technique soit ou non appropriée **dépend du contexte de l’organisation** :
      - Maturité technique et produit.
        - Les entreprises qui ont une faible maturité (tests automatisés, continuous delivery, discovery) vont mettre du temps à l’acquérir.
        - Pendant ce temps, c’est OK de garder des équipes spécialisées (développement, opérations, sécurité etc.).
      - Taille de l’organisation, et taille du logiciel.
        - Les grandes entreprises ont besoin de plateformes self-service, et éventuellement peuvent adopter le SRE, alors que les plus petites non.
    - 2 - Il y a une liste de topologies connues comme étant des **anti-patterns** allant à l’encontre de DevOps.
  - Voici quelques uns de ces patterns :
    - **Les feature teams ont besoin d’une grande maturité technique**.
      - Le fait d’avoir une feature team (une équipe pluridisciplinaire qui travaille sur une fonctionnalité de bout en bout) peut être problématique dans certains cas :
      - Dans le cas d’un shared ownership sur le code, si l’équipe passe de composants en composants pour son développement, mais n’a pas une maturité technique suffisante, elle perdra la **confiance** des autres équipes.
        - Par exemple si elle ne s’applique pas à faire de tests automatisés et n’applique pas la règle du boy scout.
    - **Les product teams ont besoin d’un système de support**.
      - Les product teams (des feature teams qui ont l’ownership sur leur produit) ont besoin que certains aspects techniques (infrastructure, environnement de test, pipelines de CI/CD etc.) soient faits pour eux.
      - L’important est que ça ne soit **pas bloquant dans leur flow de développement**.
        - Et pour ça il faut que les services en question soient fournis en **self-service**, sans avoir à aller interagir avec d’autres équipes.
    - **Les cloud teams ne doivent pas créer l’infrastructure applicative**.
      - Pour être DevOps, il faut une bonne séparation de responsabilités entre cloud teams et product teams :
        - Les cloud teams peuvent être responsables de l’infrastructure de la plateforme cloud.
        - Mais c’est les product teams qui doivent être responsables de provisionner et mettre à jour les ressources dont elles ont besoin.
    - **Le SRE a du sens à grande échelle**.
      - Les équipes SRE (Site Reliability Engineering) sont utilisées chez Google **uniquement pour les projets de grande envergure**.
      - Il s’agit d’une relation dynamique :
        - 1 - Au départ l'équipe produit gère son infra.
        - 2 - Si son produit grossit l’équipe SRE vient l’aider pour que ça marche à grande échelle.
        - 3 - Ensuite s’établit une relation où l’équipe produit établir des SLO (Service Level Objectives), et doit respecter un error budget, en collaboration avec l’équipe SRE.
          - Si elle dépasse l’error budget, l’équipe SRE peut temporairement refuser l’ajout de nouveaux changements.
        - 4 - Si l’usage de l’application diminue, l’équipe produit reprend la main sur son infra, seule.
      - La mise en place d’une équipe SRE est difficile, dans la mesure où elle implique de garder un équilibre instable entre l’implication de l’équipe produit dans les opérations, et le fait pour l’équipe SRE de fournir leur expertise.
        - En ce sens, l’équipe SRE peut être vue comme une forme particulière d’équipe **stream-aligned**.
    - **Séparer les responsabilités pour casser les silos**.
      - Par exemple on peut casser une équipe “database”, et séparer les DBA (database administration) des DB Dev (database development) :
        - Les DBA vont rejoindre une équipe Platform (ou être remplacés par l’offre Database-as-a-Service d’un cloud provider).
        - Les DB Dev vont rejoindre une équipe stream-aligned.
  - Pour bien comprendre la relation entre équipes, il est important de **maintenir une liste des dépendances entre équipes**, qui mènent à des interactions.
    - On peut les classer en 3 catégories : les dépendances de connaissances, de tâches, et de ressources.
    - Chez Spotify, les nouvelles dépendances qui sont entre squads de différentes tribes amènent à vérifier qu’il n’y a pas un problème.
  - Les DevOps Topologies doivent être utilisées en les adaptant régulièrement à l’évolution des équipes.
    - Par exemple dans le cas d’un silotage Dev et Ops, on peut introduire une équipe DevOps qui sera là pour évangéliser les pratiques, puis petit à petit disparaîtra à mesure que le Dev et l’Ops ne forment qu’un.
      - Attention à ce que ça ne devienne pas un anti-pattern où l’équipe DevOps s’installe dans la durée, et forme un silo de plus.

## 5 - The four Fundamental Team Topologies

- Il existe 4 types fondamentales d’équipes.
  - Toutes les équipes d’une entreprise devaient être ramenées à celles-là.
    - Cela permet d’éviter les anti-patterns, et d’augmenter la clarté autour du rôle de chaque équipe.
  - Les équipes Ops et Support ne sont pas dans la liste.
    - Ces équipes doivent être alignées sur le stream, et laisser les équipes avec lesquelles elles s’alignent rester DevOps.
  - **1 - Stream-Aligned Team**.
    - Un stream est un **flow continu de travail**, centré autour d’un domaine ou d’une “organizational capability”.
      - Ça peut être un produit, un service, un parcours utilisateur, un client spécifique etc.
    - Une équipe stream-aligned délivre de manière continue et **de bout en bout** (sans passage de main à une autre équipe) des incréments autour d’un stream.
      - Elle est donc **au contact régulier du client** qui utilise le produit sur lequel elle travaille.
      - Elle a une approche expérimentale et s’ajuste en permanence par le feedback qu’elle reçoit de la production.
      - L’équipe doit avoir en interne toutes les compétences nécessaires, par exemple des généralistes qui cumulent certains rôles, et des spécialistes sur d’autres.
    - Un exemple peut être les équipes principales (_service teams_) qu’Amazon utilise depuis presque 20 ans : pluridisciplinaires, autonomes, centrées autour d’un service.
  - **2 - Enabling Team**.
    - Elle est composée de personnes spécialistes de leur domaine, et qui **prennent le temps de se tenir à jour** des nouvelles technos et techniques, de tester des choses etc.
    - Ces personnes vont ensuite agir **comme des consultants**, pour guider les équipes stream-aligned, et leur donner les connaissances nécessaires pour leur contexte.
    - Leur but est de rendre les équipes stream-aligned autonomes, et de n’avoir à agir sur une équipe que **pendant quelques semaines ou mois**.
    - Exemple chez BCG Digital Ventures :
      - Ils ont constitué l’équipe suite à des problèmes d’efficacité (lead time trop long etc.), et de connaissance silotée.
      - Ils se sont concentrés sur le fait d’apprendre les bonnes pratiques aux autres équipes, à faire des pair, des mobs, y compris en filmant et diffusant les séances.
      - Leurs métriques portaient sur le nombre de déploiements, le cycle time, le temps pour fixer les incidents de prod.
        - NDLR : métriques DORA.
  - **3 - Complicated-Subsystem Team**.
    - Il s’agit d’une équipe qui travaille sur une partie spécifique d’un système, avec un besoin de **connaissance spécialisée**, au point que la plupart des membres de l’équipe doivent être spécialistes de ce sujet.
      - La différence avec les _component teams_ (équipes s’occupant de subsystems communs à plusieurs systèmes) qu’on trouve dans les organisations traditionnelles c’est le critère de forte spécialisation.
      - En quelque sorte, on accepte une équipe chargée d’un composant qui ne porte pas sur un slice vertical entier, en espérant qu’il s’agit d’une exception du fait du critère de la spécialisation.
    - Elle permet par ailleurs de soulager la cognitive load des équipes stream-aligned.
    - La relation avec les équipes stream-aligned est collaborative au début, puis plus indépendante quand l’API du subsystem se stabilise.
    - Un exemple de spécialités d’une telle équipe peut être : les connaissances sur les codecs vidéo, sur les modèles mathématiques, sur des algorithmes de reconnaissance faciale etc.
  - **4 - Platform Team**.
    - Elle développe et met à disposition des **outils self-service**, pour soulager les équipes stream-aligned d’une partie de la complexité du système.
    - Elle traite ses outils comme des **produits à destination des clients** que sont les autres équipes.
      - Elle doit donc utiliser les techniques de product management habituelles pour un produit, y compris la discovery, en itérant à partir du feedback des équipes consommatrices.
      - Elle doit porter une grande attention à l’UX (plus spécifiquement DevEx dans ce cas).
      - Elle doit traiter le produit comme un système en production : définir des horaires de disponibilité des services, une gestion des incidents etc.
      - _A platform is not just a collection of features that Dev teams happened to ask for at specific points in the past, but a holistic, well-crafted, consistent thing that takes into account the direction of technology change in the industry as a whole and the changing needs of the organization._
    - Elle peut être composée d’équipes internes à la plateforme, et pouvant être des 4 types d’équipes (on obtient une sorte de topologie fractale).
    - Des exemples de ce qui peut être dans la plateforme :
      - Provisionner des serveurs.
      - Fournir des outils pour la gestion des accès ou la sécurité.
      - Fournir un outil de logging.
      - Fournir un service de monitoring.
      - Fournir des outils de CI/CD.
    - Les auteurs parlent de **Thinnest Viable Platform** (TVP) pour insister sur le fait que la plateforme ne doit inclure que ce qui est vraiment nécessaire et utile aux autres équipes.
      - Si les composants sous-traités fonctionnent bien, la plateforme peut se résumer à une page wiki qui les décrit.
    - La plateforme est construite sur d’autres plateformes par couches successives.
      - Un cloud provider peut être une couche, on peut aussi avoir la JVM, Kubernetes, et même un OS peut être vu comme l’une des couches de plateforme.
      - Il peut être utile de faire une représentation graphique des couches de plateforme du système.
- Le flow de changements doit être fait par une même équipe stream-aligned, **sans passage de relais**.
  - Pour ça il faut éviter les silos techniques (équipes QA, DBA, UX, architecture, data processing ETL etc.).
  - Avoir une plateforme n’implique pas de passage de relais.
    - L’équipe stream-aligned n’a pas besoin de demander une action de la part de l’équipe plateforme pendant les incréments qu’elle fait, puisque les outils sont self-service.
  - Un des avantages à avoir des équipes pluridisciplinaires c’est que ça pousse à favoriser des solutions simples qui parleront à l’ensemble de l’équipe, plutôt que les solutions qui nécessitent une expertise technique poussée dans un domaine.
- Comment transformer ses équipes pour adopter le modèle de Team Topologies :
  - La **plupart des équipes** doivent devenir stream-aligned.
    - Le ratio entre stream-aligned et les trois autres réunies dans les organisations qui fonctionnent bien est entre 6:1 et 9:1.
  - Les **infrastructure teams** doivent devenir des plateform teams.
    - C’est pas forcément évident de demander d’utiliser des techniques de product management à des équipes composées d’admins système.
  - Les **component teams** doivent être dissoutes pour être intégrées aux stream-aligned teams, ou devenir une des 3 autres catégories de teams.
    - Par exemple :
      - Les équipes de DBA peuvent être converties en enabling team pour aider à monter en compétence sur la performance DB.
      - Les équipes middleware peuvent devenir des platform teams.
  - Les **tooling teams** doivent devenir des enabling teams (en général temporaires), ou faire partie de la plateforme.
  - Les **support teams** doivent s’aligner sur le stream de changement.
    - Traditionnellement les organisations ont une équipe support pour l’ensemble des services.
    - Le modèle qui marche le mieux est :
      - 1 - De créer une équipe support pour une équipe ou une famille d’équipes stream-aligned, seulement si le besoin se fait sentir.
        - Ca permet de garder chaque service ou groupe de services séparés, y compris du point de l’environnement de production (cf. loi de Conway).
        - Les support teams peuvent plus facilement amener le feedback vers l’équipe de dev.
      - 2 - D’avoir une procédure cross-équipes pour la résolution d’incidents importants.
    - L’équipe support peut être renommée “service experience team”, pour marquer le fait qu’elle n’est pas que technique.
  - Les **architecture teams** doivent :
    - soit être dissoutes pour être remplacées par les stream-aligned teams prenant leurs propres décisions et les guildes informelles permettant de faire le lien entre équipes.
    - soit rejoindre des enabling teams **à mi-temps** (pour ne pas trop empiéter sur les stream-aligned teams).
